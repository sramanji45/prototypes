from flask import Flask, request, jsonify, redirect
import requests
app = Flask(__name__)

# The hard coded secret - In real world, this is signed token generated by authentication service
EXPECTED_API_KEY = "super-secret-key-123"
LOGIN_URL = "http://localhost:5002/login"

# --- Service Mapping ---
SERVICE_MAP = {
    '/users': 'http://localhost:5001', # User Service
    "/login": "http://localhost:5002" # Login Service
}
# -----------------------

@app.route('/', defaults={'path': ''}, methods=['GET', 'POST', 'PUT', 'DELETE'])
@app.route('/<path:path>', methods=['GET', 'POST', 'PUT', 'DELETE'])
def catch_all(path):
    # Authentication
    client_api_key = request.headers.get('X-Api-Key')
    is_authenticated = (client_api_key == EXPECTED_API_KEY)

    if not is_authenticated:
        if not request.headers.get('Accept', ''):
            # If it looks like a browser, redirect the user to the login page
            print("Redirecting the user to the login page")
            return redirect(LOGIN_URL, code=302)
        else:
            # If it looks like an API call, return 401
            return jsonify({
                "error": "Unauthorized",
                "message": "Missing or invalid API Key/Token."
            }), 401

    # Calculate the Target URL
    target_url = None
    for prefix, base_url in SERVICE_MAP.items():
        if path.startswith(prefix.strip('/')):
            target_url = base_url + "/" + path
            break
    print(target_url)
    if target_url is None:
        return jsonify({"error": "Service not found for this path"}), 404

    # Forward the request to the target service
    try:
        headers = dict(request.headers)
        method = request.method
        data = request.get_data()
        resp = requests.request(method, target_url, headers=headers, data=data, params=request.args, timeout=5)
        # Instead of using backend service headers directly to the client, api-gw-apisix should regenerate the correct headers
        excluded_headers = ['content-encoding', 'content-length', 'transfer-encoding', 'connection']
        headers = [(name, value) for name, value in resp.raw.headers.items() if name.lower() not in excluded_headers]
        return resp.content, resp.status_code, headers
    except requests.exceptions.RequestException as e:
        # Handle connection errors (e.g., if the backend service is down)
        print(f"Error forwarding request: {e}")
        return jsonify({"error": "Gateway could not connect to the upstream service"}), 503
    except Exception as ex:
        return jsonify({"error": str(ex)}), 400


if __name__ == '__main__':
    app.run(port=5000)